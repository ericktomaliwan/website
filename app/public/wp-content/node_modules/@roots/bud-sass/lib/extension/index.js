import { __decorate } from "tslib";
import { Extension } from '@roots/bud-framework/extension';
import { bind, dependsOnOptional, expose, label, } from '@roots/bud-framework/extension/decorators';
import noop from '@roots/bud-support/noop';
import { BudSassOptions } from './options.js';
/**
 * Sass configuration
 */
let BudSass = class BudSass extends BudSassOptions {
    loaderPath;
    /**
     * {@link Extension.register}
     */
    async register({ build, extensions, hooks, postcss, }) {
        /* Source loader */
        this.loaderPath = await this.resolve(`sass-loader`, import.meta.url);
        if (!this.loaderPath)
            return this.logger.error(`sass-loader not found`);
        // Set loader alias
        hooks.on(`build.resolveLoader.alias`, this.onBuildResolveLoaderAlias);
        // Resolve .sass and .scss extensions
        hooks.on(`build.resolve.extensions`, this.onBuildResolveExtensions);
        /* Source sass implementation */
        const implementation = await this.import(`sass`, import.meta.url, {
            raw: true,
        }).catch(noop);
        if (!implementation) {
            return this.logger.warn(`sass implementation not explicitly resolvable. falling back on default implementation.`);
        }
        this.setImplementation(`info` in implementation ? implementation : implementation.default);
        build
            .setLoader(`sass`, `sass-loader`)
            .setItem(`sass`, {
            loader: `sass`,
            options: this.getOptions,
        })
            .setRule(`sass`, {
            include: [({ path }) => path(`@src`)],
            test: ({ hooks }) => hooks.filter(`pattern.sass`),
            use: this.withSassLoader(build.rules.css.getUse()),
        })
            .setRule(`sass-module`, {
            include: [({ path }) => path(`@src`)],
            test: ({ hooks }) => hooks.filter(`pattern.sassModule`),
            use: this.withSassLoader(build.rules[`css-module`].getUse()),
        });
        if (postcss?.setSyntax) {
            postcss.setSyntax(`postcss-scss`);
            extensions.add(await this.import(`@roots/bud-sass/resolve-url`, import.meta.url));
        }
    }
    /**
     * Import a partial globally
     *
     * @remarks
     * Used to import a partial globally (such as a `variables.scss` file)
     *
     * @example
     * With a single module signifier:
     * ```ts
     * bud.sass.importGlobal('styles/variables.scss')
     * ```
     *
     * @example
     * With an array of module signifiers:
     * ```ts
     * bud.sass.importGlobal([
     *  'styles/variables.scss',
     *  'styles/mixins.scss',
     * ])
     * ```
     *
     * @see {@link options.additionalData}
     */
    importGlobal(data) {
        const globals = (Array.isArray(data) ? data : [data])
            .map(str => str.trim())
            .filter(Boolean)
            .map(item => `@import "${item}";`);
        return this.registerGlobal(globals);
    }
    /**
     * Register global stylsheet
     *
     * @remarks
     * Used to register styles which are included globally
     *
     * @example
     * ```ts
     * bud.sass.registerGlobal(`$primary-color: #ff0000;`)
     * ```
     *
     * @see {@link Options.additionalData}
     */
    registerGlobal(additionalData) {
        this.setAdditionalData((data = ``) => {
            const processedString = (Array.isArray(additionalData) ? additionalData : [additionalData])
                .map(str => str.trim())
                .filter(Boolean)
                .join(`\n`);
            return [data, processedString].join(``);
        });
        return this;
    }
    /**
     * Callback for {@link Bud.hooks} `build.resolveLoader.alias`
     */
    onBuildResolveLoaderAlias(aliases = {}) {
        if (!this.loaderPath)
            return aliases;
        aliases[`sass-loader`] = this.loaderPath;
        return aliases;
    }
    onBuildResolveExtensions(extensions = new Set()) {
        extensions.add(`.sass`);
        extensions.add(`.scss`);
        return extensions;
    }
    withSassLoader(use = []) {
        use.push(`sass`);
        return use;
    }
};
__decorate([
    bind
], BudSass.prototype, "register", null);
__decorate([
    bind
], BudSass.prototype, "importGlobal", null);
__decorate([
    bind
], BudSass.prototype, "registerGlobal", null);
__decorate([
    bind
], BudSass.prototype, "onBuildResolveLoaderAlias", null);
__decorate([
    bind
], BudSass.prototype, "onBuildResolveExtensions", null);
__decorate([
    bind
], BudSass.prototype, "withSassLoader", null);
BudSass = __decorate([
    label(`@roots/bud-sass`),
    dependsOnOptional([`@roots/bud-postcss`]),
    expose(`sass`)
], BudSass);
export { BudSass };
export {};

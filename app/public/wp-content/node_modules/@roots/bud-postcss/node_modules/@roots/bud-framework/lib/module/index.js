import { __decorate } from "tslib";
import { join, normalize, relative } from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';
import { Service } from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators/bind';
import { BudError } from '@roots/bud-support/errors';
import { resolve } from '@roots/bud-support/import-meta-resolve';
import isEqual from '@roots/bud-support/isEqual';
import logger from '@roots/bud-support/logger';
import noop from '@roots/bud-support/noop';
/**
 * Module resolver
 */
export class Module extends Service {
    /**
     * Cached resolutions data
     */
    cache = {
        resolutions: {},
        sha1: null,
        version: null,
    };
    /**
     * Resolved module paths
     */
    resolutions = {};
    /**
     * Cache enabled
     */
    get cacheEnabled() {
        return this.args.force !== true;
    }
    /**
     * Cache location
     */
    get cachePath() {
        return join(this.paths.storage, `bud.resolutions.yml`);
    }
    /**
     * Constructor
     */
    constructor(options) {
        super(options.app);
        this.args = options.args;
        this.paths = options.paths;
    }
    /**
     * {@link Service.bootstrap}
     */
    async bootstrap(bud) {
        if (!this.cacheEnabled) {
            logger.scope(`module`).log(`Forcing reset of module cache.`);
            return await this.removeCachedResolutions();
        }
        logger.scope(`module`).log(`Cache is enabled`);
        if (await bud.fs.exists(this.cachePath)) {
            logger.scope(`module`).log(`Cache file exists:`, this.cachePath);
            const cache = await bud.fs.read(this.cachePath).catch(noop);
            if (cache)
                this.cache = cache;
            this.resolutions = { ...this.cache.resolutions };
        }
        if (!this.cache?.resolutions ||
            this.cache?.sha1 !== bud.context.files[`package`]?.sha1) {
            logger
                .scope(`module`)
                .log(`Project manifest has changed. Forcing reset of module cache.`);
            return await this.removeCachedResolutions();
        }
    }
    /**
     * At end of process write resolutions to cache
     */
    async after(bud) {
        if (isEqual(this.cache.resolutions, this.resolutions)) {
            logger.scope(`module`).log(`Resolutions unchanged. Skipping write.`);
            return bud;
        }
        await this.writeResolutions();
        return bud;
    }
    /**
     * Handle error
     *
     * @param messages - error messages for logging
     * @returns
     */
    async handleError(...messages) {
        messages.length && logger.scope(`module`).log(...messages);
        await this.removeCachedResolutions(messages.join(` `));
        throw BudError.normalize(messages.join(` `));
    }
    /**
     * Get `package.json` absolute path from a module signifier
     */
    async getDirectory(signifier, context) {
        logger.scope(`module`).info(`getDirectory`, signifier, context);
        const modulePath = await this.resolve(signifier, context);
        if (!modulePath)
            return false;
        const relativeDir = relative(this.app.context.basedir, modulePath)
            .split(signifier)
            .shift();
        return this.app.path(relativeDir, signifier);
    }
    /**
     * Get `package.json` absolute path from a module signifier
     */
    async getManifestPath(signifier) {
        logger.scope(`module`).info(`getManifestPath`, signifier);
        const directory = await this.getDirectory(signifier);
        if (!directory)
            return false;
        return this.app.path(directory, `package.json`);
    }
    /**
     * Import a module from its signifier
     */
    async import(signifier, context, options = {
        bustCache: false,
        raw: false,
        reject: true,
    }) {
        if (options.bustCache) {
            signifier = `${signifier}?v=${Date.now()}`;
        }
        if (!this.hasResolution(signifier)) {
            await this.resolve(signifier, context).catch(this.catch);
        }
        const code = await import(this.getResolution(signifier)).catch(async (error) => {
            if (options.reject)
                return await this.handleError(error.message ?? error);
        });
        if (!code && options.reject) {
            return await this.handleError(`Could not import ${signifier}`);
        }
        logger.scope(`module`).log(`Imported module:`, signifier);
        return !options.raw && `default` in code ? code.default : code;
    }
    /**
     * Make context URL
     */
    makeContextURL(context) {
        if (context instanceof URL)
            return context;
        if (context)
            return pathToFileURL(context);
        return pathToFileURL(join(this.app.context.basedir, `package.json`));
    }
    /**
     * Read `package.json` manifest from a module signifier
     */
    async readManifest(signifier) {
        const manifestPath = await this.getManifestPath(signifier);
        if (!manifestPath)
            return false;
        const value = await this.app.fs.read(manifestPath);
        logger.scope(`module`).info(signifier, `manifest`, value);
        return value;
    }
    /**
     * Reset cached resolutions
     */
    async removeCachedResolutions(error) {
        if (await this.app.fs.exists(this.cachePath)) {
            logger.scope(`module`).log(`Removing cache file:`, this.cachePath);
            await this.app.fs.remove(this.cachePath);
        }
        this.cache = {
            resolutions: {},
            sha1: this.app.context.files[`package`]?.sha1,
            version: this.app.context.bud?.version,
        };
        this.resolutions = {};
    }
    /**
     * Resolve a module path from its signifier
     */
    async resolve(signifier, context) {
        if (this.hasResolution(signifier)) {
            logger
                .scope(`module`)
                .log(`Cache hit:`, signifier, `=>`, this.getResolution(signifier));
            return this.getResolution(signifier);
        }
        const attemptResolution = (path, context) => {
            const resolvedPath = resolve(path, context);
            if (!resolvedPath)
                return false;
            return normalize(fileURLToPath(resolvedPath));
        };
        const resolved = attemptResolution(signifier, this.makeContextURL()) ??
            attemptResolution(signifier, this.makeContextURL(context));
        if (resolved) {
            logger.scope(`module`).log(`Cache miss:`, signifier, `=>`, resolved);
            this.setResolution(signifier, resolved);
        }
        return resolved;
    }
    /**
     * Write resolutions to cache
     */
    async writeResolutions(path, data) {
        logger
            .scope(`module`)
            .log(`writing resolutions`)
            .info(this.resolutions);
        await this.app.fs.write(path ?? this.cachePath, {
            resolutions: this.resolutions,
            sha1: this.app.context.files[`package`]?.sha1,
            version: this.app.context.bud.version,
            ...(data ?? {}),
        });
    }
    /**
     * Get a module resolution path
     */
    getResolution(signifier) {
        const resolved = this.resolutions[signifier];
        logger
            .scope(`module`)
            .info(`Resolved module:`, signifier, `=>`, resolved);
        return resolved;
    }
    /**
     * Check if a module has been resolved
     */
    hasResolution(signifier) {
        return signifier in this.resolutions;
    }
    /**
     * Remove a module resolution path
     *
     * @param signifier
     * @returns
     */
    removeResolution(signifier) {
        return delete this.resolutions[signifier];
    }
    /**
     * Set a module resolution path
     */
    setResolution(signifier, url) {
        this.resolutions[signifier] = url;
    }
}
__decorate([
    bind
], Module.prototype, "bootstrap", null);
__decorate([
    bind
], Module.prototype, "after", null);
__decorate([
    bind
], Module.prototype, "getDirectory", null);
__decorate([
    bind
], Module.prototype, "getManifestPath", null);
__decorate([
    bind
], Module.prototype, "import", null);
__decorate([
    bind
], Module.prototype, "makeContextURL", null);
__decorate([
    bind
], Module.prototype, "readManifest", null);
__decorate([
    bind
], Module.prototype, "removeCachedResolutions", null);
__decorate([
    bind
], Module.prototype, "resolve", null);
__decorate([
    bind
], Module.prototype, "getResolution", null);
__decorate([
    bind
], Module.prototype, "hasResolution", null);
__decorate([
    bind
], Module.prototype, "removeResolution", null);
__decorate([
    bind
], Module.prototype, "setResolution", null);
